## Общее описание и примеры

Нормализация и фильтрация баз. Например, можно из смешанной базы взять все аккаунты формата emailpass, у которых почта на домене gmail.com и пароль длиннее 15 символов, при этом приведя все емейлы к нижнему регистру и заменив разделитель на двоеточие (чтобы в итоговом файле все аккаунты выглядели как `email:password`). Кроме того, чистит базы от невалидного мусора (неверно закодированные строки, неполные аккаунты и тому подобное).

**Пример:** команда `theo n -s ":|" --min-pass 10 --fp-occurency gmail.com test.txt`

*файл test.txt в рабочей директории*

```
testmail@gmail.com;password
login:qwerty1245345
random@mail.ru;password321
long@gmail.com:logpassword
security@gmail.com|somepasswd
w^^t&fmail@gmail.com:otherlongpass
```

*итоговый файл test_normalized_1.txt в рабочей директории*

```
long@gmail.com:longpassword
security@gmail.com:somepasswd
```

Первая строка была отфильтрована, поскольку длина пароля меньше минимально разрешенной; вторая строка - не является emailpass, это logpass; третья строка удалена, поскольку точка с запятой не является допустимым разделителем, так как не входит в заданные командным аргументом `-s` сепараторы; четвертая строка является валидной и перенесена в итоговый файл без изменений; пятая строка - валидна, но при переносе в итоговый файл разделитель был заменён на разделитель по умолчанию - двоеточие; а последняя строка содержит в первой части символы, которых не может быть в емейле, и поэтому тоже удалена.



## Опции запуска

#### Основные опции

- `-b` или `--base-type` - тип обрабатываемой базы. Допустимые значения - `emailpass`, `numpass` и `logpass`. В зависимости от типа базы программа будет фильтровать невалидные строки и применять различные правила нормализации по умолчанию (например, номера не требуется приводить к lowercase и у них другой набор разрешённых символов).
  Значение по умолчанию - `emailpass`.

  

- `-s` или `--separators` - строка, содержащая исключительно те символы, которые должны считаться разделителями строк (на логин и пароль) во входном файле. Строка без разделителя будет считаться невалидной и отфильтровываться.
  Лучше всегда используйте кавычки для обособления значения аргумента. Если вы хотите, чтобы разделителем считался пробел, или чтобы программа случайно не вылетела из-за неверной обработки символов - заключите строку с разделителями, подаваемую в виде аргумента командной строки, в кавычки, например так: `": ;!"` - разделителями будут двоеточие, пробел, точка с запятой и восклицательный знак.
  Значение по умолчанию - `;:` (точка с запятой и двоеточие).

  **Пример:** команда в консоли `theo n -s "|;" test1.txt`

  *файл test1.txt в рабочей директории*

  ```
  login@mail.com:password
  testmail@gmail.com;pass
  some@mail.ru|password
  ```

  Результат после выполнения будет в файле `test1_normalized_1.txt` директории, где выполнялась команда.

  *файл test1_normalized_1.txt в рабочей директории*

  ```
  testmail@gmail.com:pass
  some@mail.ru:password
  ```

  Первая строка была отброшена, так как разделитель `:` не указан как разрешенный для входных файлов. В итоговом файле разделители были заменены на двоеточия, так как это значение по умолчанию для итогового сепаратора.

  

- `--result-sep` - один символ, итоговый сепаратор для всех строк в выходном файле. Все изначальные сепараторы будут заменены на него. 
  Значение по умолчанию - `:` (двоеточие)

  **Пример:** команда `theo n -s ";|:" --result-sep | test.txt`

  *файл test.txt в рабочей директории*

  ```
  log@mail.ru:pass
  random@gmail.com;pwds
  someemail@aol.com;qwerty16161
  ```

  *итоговый файл test_normalized_1.txt в рабочей директории*

  ```
  log@mail.ru|pass
  random@gmail.com|pwds
  someemail@aol.com|qwerty16161
  ```

  Как видно, все разделители между емейлом и паролем были заменены на символ `|` - итоговый сепаратор.
  
- `--min-pass` - положительное число больше нуля, минимально разрешённая длина пароля (части после разделителя) у аккаунта в строке, все строки с паролем меньше указанной длины в итоговый файл не попадут.
  Значение по умолчанию - `4`
  **Пример:** команда `theo n --min-pass 10 test.txt`

  *файл test.txt в рабочей директории*

  ```
  log@mail.ru:passwordlong
  random@gmail.com;pwds
  someemail@aol.com;qwerty1616
  ```

  *итоговый файл test_normalized_1.txt в рабочей директории*

  ```
  log@mail.ru:passwordlong
  someemail@aol.com:qwerty1616
  ```

  Строку, где пароль меньше десяти символов, удалило, строки, в которых в пароле больше или ровно десять символов - нормализовались и были добавлены в итоговый файл.
  
- `--max-pass` - положительное целое число, должно быть больше или равно значению параметра `--min-pass`. Максимально разрешённая длина пароля, строки, у которых часть после разделителя меньшей длины, в итоговый файл не попадут. Работает аналогично предыдущей опции, примеры считаю излишними.
  Значение по умолчанию - `63`.

#### Файловые опции

- `-m` или `--merge` - если нормализуется несколько файлов, весь результат записать в один файл, не создавая по итоговому файлу для каждого входного. По умолчанию `false`.

  **Пример:** команда `theo n -m -b logpass test1.txt test2.txt`

  *файл test1.txt в рабочей директории*

  ```
  login:pass
  testmail@gmail.com:mailpass
  ```

  *файл test2.txt в рабочей директории*

  ```
  firstpart:lastpart
  invalid;
  valid;1111
  ```

  *итоговый файл normalized_merged.txt в рабочей директории*

  ```
  login:pass
  firstpart:lastpart
  valid:1111
  ```

  В итоговый файл были записаны отфильтрованные и нормализованные строки из обоих входных файлов, вторая строка из первого файла удалена, поскольку это аккаунт emailpass, и вторая строка из второго файла тоже удалена, так как она невалидна (нет пароля).

  

- `-d` или `--destination` - путь к итоговой директории, куда будут сложены все итоговые файлы (по умолчанию - рабочая директория запуска команды), либо путь к общему итоговому файлу, если указан параметр `--merge` (по умолчанию - файл `normalized_merged.txt` в рабочей директории).

  **Пример 1:** выполняется команда `theo n -d result test.txt subfolder` в рабочей директории

  *рабочая директория*

  ```
  ├── test.txt
  ├── result/
  └── subfolder/                   
      ├── test.txt
      ├── test1.txt
  ```

  *рабочая директория после выполнения команды*

  ```
  ├── test.txt
  └── result/
  	├── test_normalized_1.txt
      ├── test_normalized_2.txt
      ├── test1_normalized_1.txt
  └── subfolder/                   
      ├── test.txt
      ├── test1.txt
  ```

  Как видно, для каждого входного файла создался итоговый файл, в котором будет результат исключительно из строк соответствующего входного файла. 
  Поскольку есть два файла с одинаковыми названиями (`test.txt` в корневой директории и `test.txt` в папке `subfolder`), то в итоговой директории первый обрабатываемый стал `test_normalized_1.txt`, а второй - `test_normalized_2.txt`. Программа работает мягко и никогда не перезаписывает файлы, а просто увеличивает число в конце имени документа.

  **Пример 2:** выполняется команда `theo n -d result_normalized.txt -m test.txt subfolder` в рабочей директории

  *рабочая директория*

  ```
  ├── test.txt
  └── subfolder/                   
      ├── test.txt
      ├── test1.txt
  ```

  *рабочая директория после выполнения команды*

  ```
  ├── test.txt
  └── subfolder/                   
      ├── test.txt
      ├── test1.txt
  ├── result_normalized.txt
  ```

  Все отфильтрованные и нормализованные строки из входных файлов сложены в один итоговый - `result_normalized.txt`.

  

- `-r` или `--recursive` - обходить ли переданные директории рекурсивно (если они переданы, на файлы никак не влияет). Булев (логический) параметр, по умолчанию false. НЕ требует передачи значения.

  **Пример:** консоль, из которой вызывается программа, открыта в корневой папке.

  *структура папок и файлов в корневой директории примера*

  ```
  ├── test1.txt
  ├── result/  
  └── testfolder/                   
      └── subfolder/
      	├── sub.txt
      ├── test2.txt 
  ```

  При вызове команды `theo n -d result test1.txt testfolder`  будут обработаны только два файла - `test1.txt` из корневой папки и файл самой указанной папки `testfolder` - `test2.txt`
  *структура папок и файлов в корневой директории после выполнения первой команды*

  ```
  ├── test1.txt
  └── result/  
  	├── test1_normalized_1.txt 
  	├── test2_normalized_1.txt 
  └── testfolder/                   
      └── subfolder/
      	├── sub.txt
      ├── test2.txt 
  ```

  

  При вызове команды `theo n -r -d result test1.txt testfolder` в итоговой директории будет результат обработки всех трёх входных файлов: `test1.txt`, `test2.txt` и `sub.txt`. Если бы в папке `subfolder` были ещё подпапки и в них были ещё текстовые документы, они бы тоже были нормализованы и результат попал бы в итоговую папку.

  *структура папок и файлов в корневой директории после выполнения второй команды*

  ```
  ├── test1.txt
  └── result/  
  	├── test1_normalized_1.txt 
  	├── test2_normalized_1.txt 
  	├── sub_normalized_1.txt 
  └── testfolder/                   
      └── subfolder/
      	├── sub.txt
      ├── test2.txt 
  ```

  



#### Дополнительные (редкоиспользуемые) опции

- `-l` или `--fp-tolower` - приводить ли к нижнему регистру первую часть строки до разделителя (емейл или логин).  Булев параметр, не требует передачи значения. По умолчанию - `true`, если передать параметр, станет `false`.

  **Пример 1:** выполняется команда `theo n -b logpass test.txt` в консоли
  *файл test.txt в рабочей директории*

  ```
  somemail@gmail.com:pass
  Login:PassworD
  UPPERcase:qwery
  randomlogin17646:pass
  ```

  *итоговый файл test_normalized_1.txt в рабочей директории*

  ```
  login:PassworD
  uppercase:qwery
  randomlogin17646:pass
  ```

  В результате отфильтровало емейл (потому что база logpass) и привело все логины в нормализованных строках к нижнему регистру. Регистр паролей затронут не был.

  **Пример 2:** выполняется команда `theo n -b logpass -l test.txt` в консоли

- `--min-fp` - положительное число, минимальная длина первой части строки (до разделителя). Строки, в которых количество символов в первой части строго меньше, отфильтровываются и не попадают в итоговый файл. 
  Значение по умолчанию - `5`.

  **Пример:** команда `theo n --min-fp 10 -b -logpass test.txt` в консоли
  *файл test.txt в рабочей директории*

  ```
  Login:PassworD
  longlogin1:password
  UPPERcase:qwery
  randomlogin17646:pass
  ```

  *итоговый файл test_normalized_1.txt в рабочей директории*

  ```
  longlogin1:password
  randomlogin17646:pass
  ```

  Поскольку длина первой части (логина), указанная пользователем, должна быть не менее 10 символов, первая и третья строки были отфильтрованы и в итоговый файл не попали.

- `--max-fp` - положительное число, максимальная длина первой части строки до разделителя. Строки, в первой части которых символов больше, отфильтровываются и не попадают в итоговый файл. Работает аналогично предыдущей опции, примеры считаю излишними.
  Значение по умолчанию - `63`.

- `--min-all` - положительное число, минимальная общая длина строки с учётом разделителя. Строки короче указанной величины удаляются и не попадают в итоговый файл. Работает аналогично предыдущим опциям.
  Значение по умолчанию - `20`.

- `--max-all` - положительное число, максимальная длина всей строки с учётом разделителя. Строки больше указанной длины удаляются и не попадают в итоговый файл. Работает аналогично предыдущим опциям.
  Значение по умолчанию - `100`.

- `-e` или `--fp-regex` - строка, валидное регулярное выражение, под которое должна подходить первая часть строки (емейл/логин/номер в зависимости от типа базы). Если опция задана, строки, у которых первая часть до сепаратора не подходит под регулярное выражение, удаляются и в итоговый файл не попадают. Регулярное выражение лучше подавать в кавычках во избежание неправильной интерпретации, особенно если в нём есть пробелы.
  Значения по умолчанию нет, если опция не задана, просто нет проверок на регулярное выражение. 

  **Пример:** команда `theo n -e "\d{4}@.+\.ru$" test.txt` в консоли

  *файл test.txt в рабочей директории*

  ```
  andrey_ivanov@list.ru:qwerty
  vasiliy_petrov1984@mail.ru:password
  testmail1337@inbox.ru:random
  testmail1337@gmail.com:other1
  ```

  *итоговый файл test_normalized_1.txt в рабочей директории*

  ```
  vasiliy_petrov1984@mail.ru:password
  testmail1337@inbox.ru:random
  ```

  В итоге остались два этих аккаунта, поскольку заданное регулярное выражение интерпретируется так: четыре цифры, затем собачка (`@`), затем некое количество символов, потом `.ru` и конец строки. Поскольку регулярное выражение обрабатывает исключительно первую часть строки без учета сепаратора, концом строки является конец емейла/логина/номера. Строки, первая часть которых не подходит под регулярное выражение - например, нет 4 цифр в конце емейла или доменная зона почты не .ru, отфильтровываются и в итоговый файл не попадают.
  
- `-p` или `--password-regex` - строка, валидное регулярное выражение, работает аналогично предыдущему параметру, только для второй части строки - пароля. Сепаратор в регулярном выражении не учитывается, как и символ переноса строки в конце. Примеры считаю излишними.
  Значения по умолчанию нет, если опция не задана, просто нет проверок на регулярное выражение. 

- `--fp-occurency` - строка, которая должна быть подстрокой первой части (до сепаратора) каждой строки из входного файла. Лучше всего применять тогда, когда нужно найти, например, только емейлы с определёнными доменами или номера с определёнными кодами в базе. Проще в понимании, чем регулярное выражение, и работает чуть ли не в десять раз быстрее. 
  Значения по умолчанию нет, если не указано, строки просто не проверяются на вхождение. 

  **Пример:** команда `theo n --fp-occurency @gmail test.txt` в консоли
  *входной файл test.txt в рабочей директории*

  ```
  somemail@list.ru:pswd
  login@gmail.com:password
  test@gmail.ua:pass
  gmail@mail.ru:test
  ```

  *итоговый файл test_normalized_1.txt в рабочей директории*

  ```
  login@gmail.com:password
  test@gmail.ua:pass
  ```

  В итоге были отфильтрованы те строки, в первой части которых не было подстроки `@gmail.com`. В последней строке входного файла, как видно, подстрока `gmail` есть в начале, однако "собаки" перед ней нету, а значит, совпадение не полное и она удаляет.
  
- `--password-occurency` - строка, которая должна быть подстрокой пароля - второй части (после сепаратора) каждой строки входного файла. В остальном всё абсолютно аналогично предыдущей опции, примеры в данном случае считаю излишними.

- `--fp-extra-allowed` - строка, содержащая дополнительно разрешённые символы в первой части строки (емейлах/логинах/паролях). 
  Для каждого типа баз есть свои основные разрешенные символы: например, для `emailpass` и `logpass` это цифры и буквы, а для `numpass` - только цифры. Однако, есть и дополнительно разрешённые символы: для `emailpass` это по умолчанию точки и символ "собачки" (`.@`), для `logpass` - нижние подчеркивания, дефисы и точки (`.-_`), для `numpass` - плюс, который может быть в начале номера, и дефисы, которые могут быть между частями номера (`+-`).  Дополнительно разрешённые символы не могут идти подряд - только между основными разрешёнными символами, кроме скобки в номере - после неё может идти пробел или тире.

  Пользователь, задавая значение данного параметра командной строки, заменяет дополнительно разрешённые символы для того типа базы, которую он обрабатывает, на свои. Допустим, если в емейлах так же разрешены нижние подчеркивания и дефисы, команда должна выглядеть как-то так: `theo n --fp-extra-allowed "-_@." somefile.txt`. Те символы, которые есть по умолчанию, необходимо указать тоже, если они всё равно нужны, поскольку пользовательская строка полностью заменяет изначальное значение параметра.

  **Пример:** 

  *исходный нормализуемый файл test.txt в рабочей директории*

  ```
  88005553535:test
  +7-909-303-13-37:random
  +7-(904)-303-13-37:twice
  8-800-555--35- 35:test2
  8 800 555 35 35:onlyspaces
  ```

  **Сначала** запускаем без указания параметра: `theo n -b numpass test.txt` 
  *итоговый файл test_normalized_1.txt в рабочей директории* 

  ```
  88005553535:test
  +7-909-303-13-37:random
  ```

  Остались только эти два номера, поскольку дополнительно разрешённые по умолчанию символы - плюс и дефис.

  **Затем** запускаем с кастомным значением параметра: `theo n -b numpass --fp-extra-allowed "+-() " test.txt`

  *итоговый файл test_normalized_2.txt в рабочей директории*

  ```
  88005553535:test
  +7-909-303-13-37:random
  +7-(904)-303-13-37:twice
  8 800 555 35 35:onlyspaces
  ```

  В итоге после нормализации был отфильтрован лишь один номер - тот, где два дополнительных разрешённых символа идут подряд, что делает первую часть невалидной. Остальные номера с указанными пользователем специальными символами прошли нормализацию успешно.