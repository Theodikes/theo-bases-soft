## Общее описание и примеры

Берёт из файла либо только те части каждой строки, которые идут до разделителя (*емейлы/логины/номера в зависимости от типа базы*), либо те, которые идут после (*пароли*). Если ни одного из указанных разделителей в строке нету, эта строка пропускается. Если до сепаратора (или после, в зависимости от того, какую часть строки мы пытаемся получить) пусто, то строка пропускается. Разделители по умолчанию стандартные для баз - двоеточие и точка с запятой.

**Пример:** выполняется команда в консоли `theo t --part last test1.txt`

*файл test1.txt в рабочей директории*

```
testmail@gmail.com:somepassword
randomstring
mail@gmail.ru:pass
nevalid:
```

В результате выполнения программы в рабочей директории будет создан итоговый файл `test1_tokenized.txt`, в котором будут находиться только пароли из входного файла.

*файл test1_tokenized.txt в рабочей директории*

```
somepassword
pass
```

Перенос (*\n*) в конце файла (после последней строки) не показан как незначащий.

## Опции запуска

#### Основные опции:

- `-p` или `--part` - та часть строки, которую необходимо получить из каждой строки входного файла. Параметр принимает значения в виде строк `first` (получить первую часть, до сепаратора не включительно) или `last` (получить вторую часть, после сепаратора), все иные значения невалидны.
  По умолчанию, если пользователь не указал - `first`.

  **Пример:** Входной файл - `test.txt` в рабочей директории.
  *файл test.txt в рабочей директории*

  ```
  testmail@gmailcom:somepass
  notamail:passw::::ord
  maybeinvalid;
  ```

  **Сначала** выполним команду `theo t -p first test.txt`. Результат после выполнения:

  *файл test_tokenized_1.txt в рабочей директории*

  ```
  testmail@gmail.com
  notamail
  ```

  Как мы видим, не записало невалидную строку базы, без второй части, даже при наличии разделителя.

  **Затем** выполним команду `theo t -p last test.txt`. Результат после выполнения:

  *файл test_tokenized_2.txt в рабочей директории*

  ```
  somepass
  passw::::ord
  ```

  Как видно, последующие символы, которые могут быть интепретированы как разделители (символы двоеточия в пароле), обрабатываются полностью корректно. Кроме того, стоит заметить, что программа не перезаписывает итоговый файл, а создаёт новый с другим числом в конце в этой же папке.

  

- `-s` или `--separators` - строка, содержащая исключительно те символы, которые должны считаться разделителями строк во входном файле. До разделителя - первая часть, после первого найденного разделителя - последняя, даже если в ней присутствуют ещё символы, которые могут считаться разделителями. 
  Лучше всегда используйте кавычки для обособления значения аргумента. Если вы хотите, чтобы разделителем считался пробел, или чтобы программа случайно не вылетела из-за неверной обработки символов - заключите строку с разделителями, подаваемую в виде аргумента командной строки, в кавычки, например так: `": ;!"` - разделителями будут двоеточие, пробел, точка с запятой и восклицательный знак.
  Значение по умолчанию - `;:` (точка с запятой и двоеточие).

  **Пример:** команда в консоли `theo -p last -s "|;" test1.txt`

  *файл test1.txt в рабочей директории*

  ```
  login:password
  testmail@gmail.com;pass
  t|wtfisthis
  ```

  Результат после выполнения будет в файле `test1_tokenized_1.txt` директории, где выполнялась команда.

  *файл test1_tokenized_1.txt в рабочей директории*

  ```
  pass
  wtfisthis
  ```

  Описываю, что произошло. Кавычки, как указано выше, лишь обособляют значение опции, поэтому реальные разделители - вертикальная черта и точка с запятой. Вторая часть первой строки, а именно слово `password`, не попало в итоговый файл, поскольку разделители по умолчанию были заменены пользовательскими разделителями, среди которых нет двоеточия.



#### Файловые опции:

- `-m` или `--merge` - если токенизируется несколько файлов, весь результат записать в один файл, не создавая по итоговому файлу для каждого входного. По умолчанию `false`.

  **Пример:** команда `theo t -m -p last test1.txt test2.txt`

  *файл test1.txt в рабочей директории*

  ```
  login:pass
  testmail@gmail.com:mailpass
  ```

  *файл test2.txt в рабочей директории*

  ```
  firstpart:lastpart
  invalid;
  valid;1
  ```

  *итоговый файл tokenized_merged.txt в рабочей директории*

  ```
  pass
  mailpass
  lastpart
  1
  ```

  В итоге из всех входных файлов валидные части строк после сепаратора были скопированы в итоговый файл. 

  

- `-d` или `--destination` - путь к итоговой директории, куда будут сложены все итоговые файлы (по умолчанию - рабочая директория запуска команды), либо путь к общему итоговому файлу, если указан параметр `--merge` (по умолчанию - файл `tokenized_merged.txt` в рабочей директории).

  **Пример 1:** выполняется команда `theo t -d result test.txt subfolder` в рабочей директории

  *рабочая директория*

  ```
  ├── test.txt
  ├── result/
  └── subfolder/                   
      ├── test.txt
      ├── test1.txt
  ```

  *рабочая директория после выполнения команды*

  ```
  ├── test.txt
  └── result/
  	├── test_tokenized_1.txt
      ├── test_tokenized_2.txt
      ├── test1_tokenized_1.txt
  └── subfolder/                   
      ├── test.txt
      ├── test1.txt
  ```

  Как видно, для каждого входного файла создался итоговый файл, в котором будет результат исключительно из строк соответствующего входного файла. 
  Поскольку есть два файла с одинаковыми названиями (`test.txt` в корневой директории и `test.txt` в папке `subfolder`), то в итоговой директории первый обрабатываемый стал `test_tokenized_1.txt`, а второй - `test_tokenized_2.txt`. Программа работает мягко и никогда не перезаписывает файлы, а просто увеличивает число в конце имени документа.

  **Пример 2:** выполняется команда `theo t -d result_tokenized.txt -m test.txt subfolder` в рабочей директории

  *рабочая директория*

  ```
  ├── test.txt
  └── subfolder/                   
      ├── test.txt
      ├── test1.txt
  ```

  *рабочая директория после выполнения команды*

  ```
  ├── test.txt
  └── subfolder/                   
      ├── test.txt
      ├── test1.txt
  ├── result_tokenized.txt
  ```

  Все итоговые части строк из входных файлов сложены в один файл, `result_tokenized.txt`.

  

- `-r` или `--recursive` - обходить ли переданные директории рекурсивно (если они переданы, на файлы никак не влияет). Булев (логический) параметр, по умолчанию false. НЕ требует передачи значения.

  **Пример:** консоль, из которой вызывается программа, открыта в корневой папке.

  *структура папок и файлов в корневой директории примера*

  ```
  ├── test1.txt
  ├── result/  
  └── testfolder/                   
      └── subfolder/
      	├── sub.txt
      ├── test2.txt 
  ```

  При вызове команды `theo t -d result test1.txt testfolder`  будут обработаны только два файла - `test1.txt` из корневой папки и файл самой указанной папки `testfolder` - `test2.txt`
  *структура папок и файлов в корневой директории после выполнения первой команды*

  ```
  ├── test1.txt
  └── result/  
  	├── test1_tokenized_1.txt 
  	├── test2_tokenized_1.txt 
  └── testfolder/                   
      └── subfolder/
      	├── sub.txt
      ├── test2.txt 
  ```

  

  При вызове команды `theo t -r -d result test1.txt testfolder` в итоговой директории будет результат обработки всех трёх входных файлов: `test1.txt`, `test2.txt` и `sub.txt`. Если бы в папке `subfolder` были ещё подпапки и в них были ещё текстовые документы, они бы тоже попали в объединённый итоговый файл.

  *структура папок и файлов в корневой директории после выполнения второй команды*

  ```
  ├── test1.txt
  └── result/  
  	├── test1_tokenized_1.txt 
  	├── test2_tokenized_1.txt 
  	├── sub_tokenized_1.txt 
  └── testfolder/                   
      └── subfolder/
      	├── sub.txt
      ├── test2.txt 
  ```

  